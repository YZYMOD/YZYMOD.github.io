<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Individual Frame Animation Test</title>
  <style>
    /* Adjust canvas dimensions to match the requested frame size for a better fit */
    #spriteCanvas {
      border: 3px solid #6c757d;
      background-color: #f8f9fa;
      display: block;
      margin: 20px auto;
    }
    body { text-align: center; font-family: Arial, sans-serif; }
  </style>
</head>
<body>
  <h1>Individual Frame Animation Test</h1>
  <canvas id="spriteCanvas" width="680" height="269"></canvas>

  <script>
    const canvas = document.getElementById('spriteCanvas');
    const ctx = canvas.getContext('2d');

    // 1. Define the frame file names and total count
    // You can adjust this array to include more frames like frame4.PNG, frame5.PNG, etc.
    const FRAME_FILES = ['frame1.PNG', 'frame2.PNG', 'frame3.PNG'];
    const FRAME_COUNT = FRAME_FILES.length;
    
    // 2. Pre-load the Image objects
    const frameImages = [];
    let imagesLoadedCount = 0;
    
    const FRAME_FPS = 12; // Frames per second for the animation
    
    function loadFrames() {
      return new Promise((resolve, reject) => {
        FRAME_FILES.forEach((fileName, index) => {
          const img = new Image();
          img.onload = () => {
            imagesLoadedCount++;
            if (imagesLoadedCount === FRAME_COUNT) {
              resolve(); // All images loaded
            }
          };
          img.onerror = () => {
             // Handle load error if necessary
             console.error(`Failed to load frame: ${fileName}`);
             imagesLoadedCount++; 
             if (imagesLoadedCount === FRAME_COUNT) resolve(); // Continue even with a failed image
          };
          img.src = fileName;
          frameImages[index] = img; // Store the image object in the array
        });
      });
    }

    let currentFrameIndex = 0;
    let lastTime = 0;
    const msPerFrame = 1000 / FRAME_FPS;

    function gameLoop(time) {
      if (!lastTime) lastTime = time;
      const delta = time - lastTime;

      if (delta >= msPerFrame) {
        // Cycle to the next frame
        currentFrameIndex = (currentFrameIndex + 1) % FRAME_COUNT;
        lastTime = time;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const currentImage = frameImages[currentFrameIndex];

      // 3. Draw the current image to fill the canvas
      if (currentImage) {
        // Draw the current frame, scaling it to fill the entire canvas (680x269)
        ctx.drawImage(
          currentImage,
          0, // sx: Source x (we use the entire image)
          0, // sy: Source y
          currentImage.width, // sWidth: Source width
          currentImage.height, // sHeight: Source height
          0, // dx: Destination x (start at canvas top-left)
          0, // dy: Destination y
          canvas.width, // dWidth: Destination width (canvas width)
          canvas.height // dHeight: Destination height (canvas height)
        );
      }

      requestAnimationFrame(gameLoop);
    }
    
    // Start the process: load images, then start the loop
    loadFrames()
        .then(() => {
            console.log("All frames loaded. Starting animation.");
            // Set canvas size to the desired output size (680x269)
            canvas.width = 680;
            canvas.height = 269;
            requestAnimationFrame(gameLoop);
        })
        .catch(error => {
            console.error("Error loading frames:", error);
            alert("Failed to load animation frames.");
        });

  </script>
</body>
</html>
